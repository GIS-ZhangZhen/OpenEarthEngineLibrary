var inputs=[{name:'radius',description:'the half size of the windows use to get neighbours', type:'integer',defaultValue:10 ,optional:false},
            {name:'covFun',description:'the covariance function,fun(ee.Array)', type:'function' ,optional:false},
            {name:'skipInfomed',description:'do not compute on informed locations. To set to false in presence of a kernel with a 0 in the center', type:'boolean',optional:true},
            {name:'kernel',description:'neigbours with weight equal to 0 are ignored, teh size need to be compatible with the radius', type:'ee.Kernel',optional:true},
            {name:'image',description:'the image on with to run the computation ', type:'ee.Image',optional:true},
            {name:'Return',description:'Return', type:'function|ee.Image',defaultValue:null,optional:true}]
            
var reference={name:'kriging',license:'GPLv3', description:'Compute a gap filling interpolation uisng kriging. It return a function, or apply on an image if "image" is informed and return the result of the computation.'};

exports.createDocumentation=function(){ return {inputs:inputs, reference:reference};}

exports.createFunction=function(internal,relPath){
return function(){
    var inputDictionary=internal.readInputs(Array.prototype.slice.call(arguments,0),inputs,reference,relPath);
    internal.addRef(reference);
    
    var halfSize=inputDictionary.radius;
    var dataKernel=inputDictionary.kernel;

    var X=ee.Array(ee.List.sequence(-halfSize,halfSize,1)).repeat(1, halfSize*2+1)//.reshape([-1]);
    var Y=ee.Array(ee.List.sequence(-halfSize,halfSize,1)).repeat(1, halfSize*2+1).transpose()//.reshape([-1]);
    var covFun=inputDictionary.covFun;
    
    var numberOfElement=(halfSize*2+1)*(halfSize*2+1);
    
    var dist=ee.Array.cat([X,Y], 2);
    
    var distK=dist.reshape([-1,1,2]).repeat(1,numberOfElement).subtract(dist.reshape([1,-1,2]).repeat(0,numberOfElement));
    distK=distK.pow(2).reduce(ee.Reducer.sum(), [2]).sqrt().reshape([(halfSize*2+1)*(halfSize*2+1),(halfSize*2+1)*(halfSize*2+1)]);
    var K=covFun(distK);
    K=K.add(ee.Array.identity(numberOfElement)).pad([(numberOfElement+1),(numberOfElement+1)],1).subtract(ee.Array.identity((numberOfElement+1)));
    
    var K0=covFun(dist.pow(2).reduce(ee.Reducer.sum(), [2]).sqrt().reshape([-1,1])).pad([numberOfElement+1,0],1);
    
    var ImageK=ee.Image.constant(K);
    var ImageK0=ee.Image.constant(K0);
    
    var kernel=ee.Kernel.square(halfSize);
    
    var fun=function(im){
      var mask=im.mask().neighborhoodToArray({kernel:kernel, defaultValue:0}).arrayReshape(ee.Array([-1]),1).arrayPad([numberOfElement+1],1);
      var r=im.unmask(0).neighborhoodToArray({kernel:kernel, defaultValue:0}).arrayReshape(ee.Array([-1]),1).arrayPad([numberOfElement+1],0).arrayMask(mask);
    
      mask=mask.arrayReshape(ee.Array([-1,1]),2);
      

      ImageK0=ImageK0.arrayMask(mask);
      
      var dataSize=ImageK0.gt(0).arrayReduce(ee.Reducer.sum(),[0]).arrayGet([0,0]).gt(3);
      
      var coef=ImageK.arrayMask(mask).arrayTranspose().arrayMask(mask).matrixSolve(ImageK0).arrayReshape(ee.Array([-1]),1);
      print(coef)
      var estimate=coef.multiply(r).arrayReduce(ee.Reducer.sum(),[0]).arrayGet([0]).updateMask(dataSize);
      var variance=coef.multiply(ImageK0.arrayReshape(ee.Array([-1]),1)).arrayReduce(ee.Reducer.sum(),[0]).subtract(covFun(ee.Array([0]))).arrayGet([0])
              .subtract(coef.arrayGet([-1]).multiply(2)).multiply(-1).updateMask(dataSize);
      
      var reuslt=im.addBands([estimate.where(im,im).rename('estimate'),variance.where(im,0).rename('variance')]);
      
      reuslt=reuslt.reproject(Simard.projection())
  
  
      var kernel=ee.Kernel.fixed(2*xSize+1, 2*ySize+1, val, xSize, ySize, false).inverse();
    

      return result.where(im,im).reproject(im.projection());
    }
    
    if(inputDictionary.image)
      return fun(inputDictionary.image);
    else
      return fun;
  }
}

