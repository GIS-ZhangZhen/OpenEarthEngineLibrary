var inputs=[{name:'collection',description:'The image collection on which to perform the filtering', type:'ee.ImageCollection',defaultValue:null,optional:false},
            {name:'filter',description:'moving windows filter', type:'ee.Filter',defaultValue:null,optional:false},
            {name:'distanceFunction',description:'a lambda fucntion that specify how to compute distance between two image that return an ee.Image (or a ee.Number to add)', type:'fucntion(ee.Image(infromedImage),ee.Image(estimationImage))',defaultValue:null,optional:false},
            {name:'degree',description:'Polynomial degree, odd number >2', type:'ee.Number',defaultValue:3,optional:true},
            {name:'bandOfInterest',description:'bands selector, by default all of them', type:'band selector',defaultValue:3,optional:true},
            {name:'EstimationCollection',description:'specify the collection where to do the estimations (by default use the main collection)', type:'ee.Collection',defaultValue:null,optional:true},]
            
var reference={name:'test',license:'MIT', description:'blabla'};

exports.createDocumentation=function(){ return {inputs:inputs, reference:reference};}

exports.createFunction=function(internal,relPath){
return function(){
    var inputDictionary=internal.readInputs(Array.prototype.slice.call(arguments,0),inputs,reference,relPath);
    internal.addRef(reference);
    
    if(!inputDictionary.EstimationCollection){
      inputDictionary.EstimationCollection=inputDictionary.collection;
    }

    var saveAllJoin = ee.Join.saveAll({
      matchesKey: 'neighbours',  //every day of the year is a neighbor... 180 days both directions
      measureKey: 'distanceError' //join condition...
    });
    
    saveAllJoin.apply(inputDictionary.collection, inputDictionary.EstimationCollection, inputDictionary.filter).map(
    function(im){
      var imCol=ee.ImageCollection(ee.List(im.get('neighbours')));
      imCol=imCol.map(function(Nim){ // compute the temporal distance and add it as a band
          var delta=inputDictionary.distanceFunction(Nim,im);
          delta=delta.toArray(0).arrayRepeat(1, inputDictionary.degree)
            .pow(ee.Array(Array.apply(0, Array(inputDictionary.degree)).map(function(_,i) { return i; })))
            return Nim.addBands(delta.rename('delta').toFloat());
      })
      var matrix=imCol.toArrayPerBand(0);
      var matrixWithSelectedBands=matrix.select('NDVI.*');
      var coef=matrix.select('delta').matrixSolve(matrixWithSelectedBands.toArray(1));
      var coef0=coef.arraySlice(0, 0, 1)
      return im.addBands(coef0.arrayFlatten([['interp'],matrixWithSelectedBands.bandNames()]));
    });
         
    //do whatever
    return inputDictionary.val;
  }
}
